using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEngine.Rendering
{

public class CommandBuffer : IDisposable
{
    public string name { get; set; }
    public int sizeInBytes { get; }

    public CommandBuffer();

    public void BeginSample(string name);
    public void BeginSample(Profiling.CustomSampler sampler);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest);
    public void Blit(Texture source, Rendering.RenderTargetIdentifier dest);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, Material mat);
    public void Blit(Texture source, Rendering.RenderTargetIdentifier dest, Material mat);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, Material mat, int pass);
    public void Blit(Texture source, Rendering.RenderTargetIdentifier dest, Material mat, int pass);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
    public void Blit(Texture source, Rendering.RenderTargetIdentifier dest, Vector2 scale, Vector2 offset);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, int sourceDepthSlice, int destDepthSlice);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, Material mat, int pass, int destDepthSlice);
    public void Blit(Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, Vector2 scale, Vector2 offset, int sourceDepthSlice, int destDepthSlice);
    public void BuildRayTracingAccelerationStructure(Experimental.Rendering.RayTracingAccelerationStructure accelerationStructure);
    public void Clear();
    public void ClearRandomWriteTargets();
    public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor);
    public void ClearRenderTarget(bool clearDepth, bool clearColor, Color backgroundColor, float depth);
    public void ConvertTexture(Rendering.RenderTargetIdentifier src, Rendering.RenderTargetIdentifier dst);
    public void ConvertTexture(Rendering.RenderTargetIdentifier src, int srcElement, Rendering.RenderTargetIdentifier dst, int dstElement);
    public void CopyCounterValue(ComputeBuffer src, ComputeBuffer dst, uint dstOffsetBytes);
    public void CopyCounterValue(ComputeBuffer src, GraphicsBuffer dst, uint dstOffsetBytes);
    public void CopyCounterValue(GraphicsBuffer src, ComputeBuffer dst, uint dstOffsetBytes);
    public void CopyCounterValue(GraphicsBuffer src, GraphicsBuffer dst, uint dstOffsetBytes);
    public void CopyTexture(Rendering.RenderTargetIdentifier src, Rendering.RenderTargetIdentifier dst);
    public void CopyTexture(Rendering.RenderTargetIdentifier src, int srcElement, Rendering.RenderTargetIdentifier dst, int dstElement);
    public void CopyTexture(Rendering.RenderTargetIdentifier src, int srcElement, int srcMip, Rendering.RenderTargetIdentifier dst, int dstElement, int dstMip);
    public void CopyTexture(Rendering.RenderTargetIdentifier src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Rendering.RenderTargetIdentifier dst, int dstElement, int dstMip, int dstX, int dstY);
    public Rendering.GraphicsFence CreateAsyncGraphicsFence();
    public Rendering.GraphicsFence CreateAsyncGraphicsFence(Rendering.SynchronisationStage stage);
    public Rendering.GPUFence CreateGPUFence();
    public Rendering.GPUFence CreateGPUFence(Rendering.SynchronisationStage stage);
    public Rendering.GraphicsFence CreateGraphicsFence(Rendering.GraphicsFenceType fenceType, Rendering.SynchronisationStageFlags stage);
    public void DisableScissorRect();
    public void DisableShaderKeyword(string keyword);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, ComputeBuffer indirectBuffer, uint argsOffset);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, GraphicsBuffer indirectBuffer, uint argsOffset);
    public void DispatchCompute(ComputeShader computeShader, int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ);
    public void DispatchRays(Experimental.Rendering.RayTracingShader rayTracingShader, string rayGenName, uint width, uint height, uint depth, Camera camera = null);
    public void Dispose();
    public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material);
    public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex);
    public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass);
    public void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int submeshIndex, int shaderPass, MaterialPropertyBlock properties);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count);
    public void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, int shaderPass, Matrix4x4[] matrices, int count, MaterialPropertyBlock properties);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, int shaderPass, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawMeshInstancedProcedural(Mesh mesh, int submeshIndex, Material material, int shaderPass, int count, MaterialPropertyBlock properties = null);
    public void DrawOcclusionMesh(RectInt normalizedCamViewport);
    public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount);
    public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount);
    public void DrawProcedural(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int vertexCount, int instanceCount, MaterialPropertyBlock properties);
    public void DrawProcedural(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, int indexCount, int instanceCount, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawProceduralIndirect(GraphicsBuffer indexBuffer, Matrix4x4 matrix, Material material, int shaderPass, MeshTopology topology, GraphicsBuffer bufferWithArgs, int argsOffset, MaterialPropertyBlock properties);
    public void DrawRenderer(Renderer renderer, Material material);
    public void DrawRenderer(Renderer renderer, Material material, int submeshIndex);
    public void DrawRenderer(Renderer renderer, Material material, int submeshIndex, int shaderPass);
    public void EnableScissorRect(Rect scissor);
    public void EnableShaderKeyword(string keyword);
    public void EndSample(string name);
    public void EndSample(Profiling.CustomSampler sampler);
    public void GenerateMips(RenderTexture rt);
    public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc);
    public void GetTemporaryRT(int nameID, RenderTextureDescriptor desc, FilterMode filter);
    public void GetTemporaryRT(int nameID, int width, int height);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode);
    public void GetTemporaryRT(int nameID, int width, int height, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite, RenderTextureMemoryless memorylessMode, bool useDynamicScale);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing, bool enableRandomWrite);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, Experimental.Rendering.GraphicsFormat format, int antiAliasing, bool enableRandomWrite, bool useDynamicScale);
    public void GetTemporaryRTArray(int nameID, int width, int height, int slices, int depthBuffer, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite, int antiAliasing, bool enableRandomWrite);
    public void IncrementUpdateCount(Rendering.RenderTargetIdentifier dest);
    public void IssuePluginCustomBlit(IntPtr callback, uint command, Rendering.RenderTargetIdentifier source, Rendering.RenderTargetIdentifier dest, uint commandParam, uint commandFlags);
    public void IssuePluginCustomTextureUpdate(IntPtr callback, Texture targetTexture, uint userData);
    public void IssuePluginCustomTextureUpdateV1(IntPtr callback, Texture targetTexture, uint userData);
    public void IssuePluginCustomTextureUpdateV2(IntPtr callback, Texture targetTexture, uint userData);
    public void IssuePluginEvent(IntPtr callback, int eventID);
    public void IssuePluginEventAndData(IntPtr callback, int eventID, IntPtr data);
    public void ProcessVTFeedback(Rendering.RenderTargetIdentifier rt, IntPtr resolver, int slice, int x, int width, int y, int height, int mip);
    public void Release();
    public void ReleaseTemporaryRT(int nameID);
    public void RequestAsyncReadback(ComputeBuffer src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(GraphicsBuffer src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, Experimental.Rendering.GraphicsFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, TextureFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(ComputeBuffer src, int size, int offset, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(GraphicsBuffer src, int size, int offset, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Experimental.Rendering.GraphicsFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadback(Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, ComputeBuffer src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, GraphicsBuffer src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, Experimental.Rendering.GraphicsFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, TextureFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, ComputeBuffer src, int size, int offset, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, GraphicsBuffer src, int size, int offset, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, Experimental.Rendering.GraphicsFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void RequestAsyncReadbackIntoNativeArray<T>(Unity.Collections.NativeArray<T> output, Texture src, int mipIndex, int x, int width, int y, int height, int z, int depth, TextureFormat dstFormat, Action<Rendering.AsyncGPUReadbackRequest> callback);
    public void ResolveAntiAliasedSurface(RenderTexture rt, RenderTexture target = null);
    public void SetComputeBufferCounterValue(ComputeBuffer buffer, uint counterValue);
    public void SetComputeBufferData(ComputeBuffer buffer, Array data);
    public void SetComputeBufferData(ComputeBuffer buffer, Array data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    public void SetComputeBufferData<T>(ComputeBuffer buffer, List<T> data);
    public void SetComputeBufferData<T>(ComputeBuffer buffer, Unity.Collections.NativeArray<T> data);
    public void SetComputeBufferData<T>(ComputeBuffer buffer, List<T> data, int managedBufferStartIndex, int graphicsBufferStartIndex, int count);
    public void SetComputeBufferData<T>(ComputeBuffer buffer, Unity.Collections.NativeArray<T> data, int nativeBufferStartIndex, int graphicsBufferStartIndex, int count);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, ComputeBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, string name, GraphicsBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, ComputeBuffer buffer);
    public void SetComputeBufferParam(ComputeShader computeShader, int kernelIndex, int nameID, GraphicsBuffer buffer);
    public void SetComputeConstantBufferParam(ComputeShader computeShader, int nameID, ComputeBuffer buffer, int offset, int size);
    public void SetComputeFloatParam(ComputeShader computeShader, string name, float val);
    public void SetComputeFloatParam(ComputeShader computeShader, int nameID, float val);
    public void SetComputeFloatParams(ComputeShader computeShader, string name, float[] values);
    public void SetComputeFloatParams(ComputeShader computeShader, int nameID, float[] values);
    public void SetComputeIntParam(ComputeShader computeShader, string name, int val);
    public void SetComputeIntParam(ComputeShader computeShader, int nameID, int val);
    public void SetComputeIntParams(ComputeShader computeShader, string name, int[] values);
    public void SetComputeIntParams(ComputeShader computeShader, int nameID, int[] values);
    public void SetComputeMatrixArrayParam(ComputeShader computeShader, string name, Matrix4x4[] values);
    public void SetComputeMatrixArrayParam(ComputeShader computeShader, int nameID, Matrix4x4[] values);
    public void SetComputeMatrixParam(ComputeShader computeShader, string name, Matrix4x4 val);
    public void SetComputeMatrixParam(ComputeShader computeShader, int nameID, Matrix4x4 val);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, Rendering.RenderTargetIdentifier rt);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, Rendering.RenderTargetIdentifier rt);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, Rendering.RenderTargetIdentifier rt, int mipLevel);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, Rendering.RenderTargetIdentifier rt, int mipLevel);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, string name, Rendering.RenderTargetIdentifier rt, int mipLevel, Rendering.RenderTextureSubElement element);
    public void SetComputeTextureParam(ComputeShader computeShader, int kernelIndex, int nameID, Rendering.RenderTargetIdentifier rt, int mipLevel, Rendering.RenderTextureSubElement element);
    public void SetComputeVectorArrayParam(ComputeShader computeShader, string name, Vector4[] values);
    public void SetComputeVectorArrayParam(ComputeShader computeShader, int nameID, Vector4[] values);
    public void SetComputeVectorParam(ComputeShader computeShader, string name, Vector4 val);
    public void SetComputeVectorParam(ComputeShader computeShader, int nameID, Vector4 val);
    public void SetExecutionFlags(Rendering.CommandBufferExecutionFlags flags);
    public void SetGlobalBuffer(string name, ComputeBuffer value);
    public void SetGlobalBuffer(string name, GraphicsBuffer value);
    public void SetGlobalBuffer(int nameID, ComputeBuffer value);
    public void SetGlobalBuffer(int nameID, GraphicsBuffer value);
    public void SetGlobalColor(string name, Color value);
    public void SetGlobalColor(int nameID, Color value);
    public void SetGlobalConstantBuffer(ComputeBuffer buffer, string name, int offset, int size);
    public void SetGlobalConstantBuffer(GraphicsBuffer buffer, string name, int offset, int size);
    public void SetGlobalConstantBuffer(ComputeBuffer buffer, int nameID, int offset, int size);
    public void SetGlobalConstantBuffer(GraphicsBuffer buffer, int nameID, int offset, int size);
    public void SetGlobalDepthBias(float bias, float slopeBias);
    public void SetGlobalFloat(string name, float value);
    public void SetGlobalFloat(int nameID, float value);
    public void SetGlobalFloatArray(int nameID, List<float> values);
    public void SetGlobalFloatArray(int nameID, float[] values);
    public void SetGlobalFloatArray(string propertyName, List<float> values);
    public void SetGlobalFloatArray(string propertyName, float[] values);
    public void SetGlobalInt(string name, int value);
    public void SetGlobalInt(int nameID, int value);
    public void SetGlobalMatrix(string name, Matrix4x4 value);
    public void SetGlobalMatrix(int nameID, Matrix4x4 value);
    public void SetGlobalMatrixArray(int nameID, List<Matrix4x4> values);
    public void SetGlobalMatrixArray(int nameID, Matrix4x4[] values);
    public void SetGlobalMatrixArray(string propertyName, List<Matrix4x4> values);
    public void SetGlobalMatrixArray(string propertyName, Matrix4x4[] values);
    public void SetGlobalTexture(string name, Rendering.RenderTargetIdentifier value);
    public void SetGlobalTexture(int nameID, Rendering.RenderTargetIdentifier value);
    public void SetGlobalTexture(string name, Rendering.RenderTargetIdentifier value, Rendering.RenderTextureSubElement element);
    public void SetGlobalTexture(int nameID, Rendering.RenderTargetIdentifier value, Rendering.RenderTextureSubElement element);
    public void SetGlobalVector(string name, Vector4 value);
    public void SetGlobalVector(int nameID, Vector4 value);
    public void SetGlobalVectorArray(int nameID, List<Vector4> values);
    public void SetGlobalVectorArray(int nameID, Vector4[] values);
    public void SetGlobalVectorArray(string propertyName, List<Vector4> values);
    public void SetGlobalVectorArray(string propertyName, Vector4[] values);
    public void SetInstanceMultiplier(uint multiplier);
    public void SetInvertCulling(bool invertCulling);
    public void SetProjectionMatrix(Matrix4x4 proj);
    public void SetRandomWriteTarget(int index, ComputeBuffer buffer);
    public void SetRandomWriteTarget(int index, GraphicsBuffer buffer);
    public void SetRandomWriteTarget(int index, Rendering.RenderTargetIdentifier rt);
    public void SetRandomWriteTarget(int index, ComputeBuffer buffer, bool preserveCounterValue);
    public void SetRandomWriteTarget(int index, GraphicsBuffer buffer, bool preserveCounterValue);
    public void SetRayTracingAccelerationStructure(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Experimental.Rendering.RayTracingAccelerationStructure rayTracingAccelerationStructure);
    public void SetRayTracingAccelerationStructure(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Experimental.Rendering.RayTracingAccelerationStructure rayTracingAccelerationStructure);
    public void SetRayTracingBufferParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, ComputeBuffer buffer);
    public void SetRayTracingBufferParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, ComputeBuffer buffer);
    public void SetRayTracingFloatParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, float val);
    public void SetRayTracingFloatParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, float val);
    public void SetRayTracingFloatParams(Experimental.Rendering.RayTracingShader rayTracingShader, string name, float[] values);
    public void SetRayTracingFloatParams(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, float[] values);
    public void SetRayTracingIntParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, int val);
    public void SetRayTracingIntParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, int val);
    public void SetRayTracingIntParams(Experimental.Rendering.RayTracingShader rayTracingShader, string name, int[] values);
    public void SetRayTracingIntParams(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, int[] values);
    public void SetRayTracingMatrixArrayParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Matrix4x4[] values);
    public void SetRayTracingMatrixArrayParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Matrix4x4[] values);
    public void SetRayTracingMatrixParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Matrix4x4 val);
    public void SetRayTracingMatrixParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Matrix4x4 val);
    public void SetRayTracingShaderPass(Experimental.Rendering.RayTracingShader rayTracingShader, string passName);
    public void SetRayTracingTextureParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Rendering.RenderTargetIdentifier rt);
    public void SetRayTracingTextureParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Rendering.RenderTargetIdentifier rt);
    public void SetRayTracingVectorArrayParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Vector4[] values);
    public void SetRayTracingVectorArrayParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Vector4[] values);
    public void SetRayTracingVectorParam(Experimental.Rendering.RayTracingShader rayTracingShader, string name, Vector4 val);
    public void SetRayTracingVectorParam(Experimental.Rendering.RayTracingShader rayTracingShader, int nameID, Vector4 val);
    public void SetRenderTarget(Rendering.RenderTargetBinding binding);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier color, Rendering.RenderTargetIdentifier depth);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier[] colors, Rendering.RenderTargetIdentifier depth);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt, int mipLevel);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier color, Rendering.RenderTargetIdentifier depth, int mipLevel);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt, Rendering.RenderBufferLoadAction loadAction, Rendering.RenderBufferStoreAction storeAction);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace);
    public void SetRenderTarget(Rendering.RenderTargetBinding binding, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier color, Rendering.RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier color, Rendering.RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier[] colors, Rendering.RenderTargetIdentifier depth, int mipLevel, CubemapFace cubemapFace, int depthSlice);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier rt, Rendering.RenderBufferLoadAction colorLoadAction, Rendering.RenderBufferStoreAction colorStoreAction, Rendering.RenderBufferLoadAction depthLoadAction, Rendering.RenderBufferStoreAction depthStoreAction);
    public void SetRenderTarget(Rendering.RenderTargetIdentifier color, Rendering.RenderBufferLoadAction colorLoadAction, Rendering.RenderBufferStoreAction colorStoreAction, Rendering.RenderTargetIdentifier depth, Rendering.RenderBufferLoadAction depthLoadAction, Rendering.RenderBufferStoreAction depthStoreAction);
    public void SetShadowSamplingMode(Rendering.RenderTargetIdentifier shadowmap, Rendering.ShadowSamplingMode mode);
    public void SetSinglePassStereo(Rendering.SinglePassStereoMode mode);
    public void SetViewMatrix(Matrix4x4 view);
    public void SetViewport(Rect pixelRect);
    public void SetViewProjectionMatrices(Matrix4x4 view, Matrix4x4 proj);
    public void WaitAllAsyncReadbackRequests();
    public void WaitOnAsyncGraphicsFence(Rendering.GraphicsFence fence);
    public void WaitOnAsyncGraphicsFence(Rendering.GraphicsFence fence, Rendering.SynchronisationStage stage);
    public void WaitOnAsyncGraphicsFence(Rendering.GraphicsFence fence, Rendering.SynchronisationStageFlags stage);
    public void WaitOnGPUFence(Rendering.GPUFence fence);
    public void WaitOnGPUFence(Rendering.GPUFence fence, Rendering.SynchronisationStage stage);

}

}
